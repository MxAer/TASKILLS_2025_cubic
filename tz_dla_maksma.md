Это ТЗ ориентировано на реализацию **4-го этапа (Real-time Multiplayer)** и подготовку к 5-му. Оно написано на языке, понятном Go-разработчику, с указанием конкретных структур данных и контрактов API.

---

# Техническое Задание: Реализация Multiplayer Core (WebSockets + Redis)

## 1. Контекст проекта
Разрабатывается приложение "Dice Roller".
*   **Текущее состояние:** Реализован REST API для создания комнат и гостевой авторизации (JWT/Cookie). Поднята инфраструктура (Postgres, Redis). Фронтенд умеет бросать кубики локально.
*   **Цель этапа:** Реализовать синхронизацию бросков между пользователями в одной комнате в реальном времени.

## 2. Стек
*   **Language:** Go 1.21+
*   **Router:** Chi
*   **Realtime:** `github.com/gorilla/websocket` (или аналог)
*   **DB:** PostgreSQL (хранение истории)
*   **Bus:** Redis Pub/Sub (обмен сообщениями между инстансами/клиентами)

---

## 3. Задачи разработчика

### Задача А: Реализация WebSocket Hub
Необходимо создать `Hub`, который управляет активными соединениями.
1.  **Endpoint:** `GET /ws/{roomId}`
    *   Проверять куку авторизации (существующий middleware `mw.AuthMiddleware`).
    *   При подключении добавлять пользователя в пул соединения комнаты `{roomId}`.
    *   При отключении удалять из пула.

2.  **Redis Pub/Sub:**
    *   Каждая комната подписывается на канал в Redis: `room:{roomId}:events`.
    *   Все сообщения, приходящие в WS, должны публиковаться в Redis.
    *   Все сообщения из Redis должны рассылаться всем активным WS-клиентам в этой комнате.

### Задача Б: Протокол обмена (JSON Contract)
Реализовать обработку следующих типов сообщений (Event-based architecture):

#### 1. Вход пользователя (`USER_JOINED`)
*   **Триггер:** Успешное WS соединение.
*   **Действие:** Разослать всем в комнате уведомление.
*   **Payload:** `{ "type": "USER_JOINED", "payload": { "userId": "uuid", "username": "Guest" } }`

#### 2. Начало броска (`THROW_START`)
*   **Триггер:** Клиент нажимает "Roll" (отправляет вектор силы).
*   **Действие:** Сервер транслирует это сообщение всем остальным **мгновенно**, чтобы у них началась анимация.
*   **Входящий JSON:**
    ```json
    {
      "type": "THROW_START",
      "payload": {
        "impulse": { "x": 0.5, "y": -10, "z": 0.2 },
        "torque": { "x": 1, "y": 1, "z": 1 },
        "diceCount": 2,
        "diceType": "d6"
      }
    }
    ```

#### 3. Результат броска (`THROW_RESULT`)
*   **Логика:** Физика считается на клиенте "бросающего". Когда кубики остановились, клиент шлет результат.
*   **Действие сервера:**
    1.  Валидация (проверить, что `values` соответствуют типу кубика).
    2.  **Сохранение в БД:** Записать бросок в таблицу `rolls`.
    3.  Трансляция всем клиентам.
*   **Входящий JSON:**
    ```json
    {
      "type": "THROW_RESULT",
      "payload": {
        "values": [4, 6], // Выпавшие грани
        "positions": [...] // Координаты (опционально, для синхронизации позиций)
      }
    }
    ```

### Задача В: История бросков
Добавить REST endpoint (или отправлять по WS при входе) для получения последних 50 бросков.
*   `GET /api/room/{roomId}/history`
*   Должен возвращать JSON с данными из таблицы `rolls` + join таблицы `users` (чтобы видеть имена).

---

## 4. Требования к реализации (Definition of Done)

1.  **Структура пакетов:** Код WS логики должен лежать изолированно, например в `internal/realtime/`.
2.  **Конкурентность:** Использование мьютексов (`sync.RWMutex`) для управления мапой подключений `rooms[id] -> clients[]`.
3.  **Graceful Shutdown:** При остановке сервера закрывать соединения корректно.
4.  **База данных:**
    *   Использовать существующую таблицу `rolls`.
    *   Заполнять поле `result_data` (тип JSONB) полным дампом броска.

## 5. Пример сценария работы

1.  `User A` и `User B` заходят в комнату `UUID-1`.
2.  Оба устанавливают WS соединение.
3.  `User A` нажимает кнопку броска.
4.  Бэкенд получает `THROW_START` от A.
5.  Бэкенд отправляет `THROW_START` пользователю B.
6.  У `User B` на экране кубики начинают лететь (с теми же параметрами силы, что и у A).
7.  У `User A` кубики остановились, выпало `5` и `2`.
8.  Бэкенд получает `THROW_RESULT` от A.
9.  Бэкенд сохраняет это в Postgres.
10. Бэкенд отправляет `THROW_RESULT` пользователю B (для подтверждения и записи в лог чата).

---

## 6. Полезные материалы для старта
*   Существующая модель `Roll`:
    ```go
    type Roll struct {
        ID        int             `json:"id"`
        RoomID    uuid.UUID       `json:"room_id"`
        UserID    uuid.UUID       `json:"user_id"`
        Config    string          `json:"config"` // "2d6"
        Result    json.RawMessage `json:"result"`
    }
    ```
*   Библиотека WebSocket: `go get github.com/gorilla/websocket`